# Roadmap de Retos de Programación - MoureDev

## Introducción

En este repositorio el objetivo es reforzar mis conocimientos en TypeScript resolviendo los ejercicios de este roadmap, no estoy utilizando ningún tupo de framework para llevarlo acabo por lo cual utilizo directamente TypeScript en el navegador, te dejo la descripcion de los ejercicios tal cual aparece en la pagina o si prefieres puedes acceder a https://retosdeprogramacion.com/roadmap para leer y/o crear tus propias soluciones 

## Ejercicios

### Nivel Fácil

1. **#0 - El famoso "FizzBuzz"**
   - Descripción: Escribe un programa que muestre por consola los números del 1 al 100, sustituyendo los múltiplos de 3 por "fizz", los múltiplos de 5 por "buzz" y los múltiplos de ambos por "fizzbuzz".

2. **#1 - Contador de vocales**
   - Descripción: Crea una función que cuente cuántas vocales hay en una cadena de texto.

3. **#2 - Palíndromos**
   - Descripción: Escribe una función que determine si una palabra o frase es un palíndromo (se lee igual de izquierda a derecha que de derecha a izquierda).

4. **#3 - Números primos**
   - Descripción: Crea una función que determine si un número es primo.

5. **#4 - Fibonacci**
   - Descripción: Escribe una función que genere la secuencia de Fibonacci hasta un número dado.

6. **#5 - Factorial**
   - Descripción: Crea una función que calcule el factorial de un número.

7. **#6 - Inversión de cadenas**
   - Descripción: Escribe una función que invierta una cadena de texto.

8. **#7 - Suma de números**
   - Descripción: Crea una función que calcule la suma de todos los números en un arreglo.

9. **#8 - Promedio**
   - Descripción: Escribe una función que calcule el promedio de los números en un arreglo.

10. **#9 - Máximo y mínimo**
    - Descripción: Crea una función que encuentre el número máximo y mínimo en un arreglo.

### Nivel Medio

11. **#10 - Ordenamiento**
    - Descripción: Implementa un algoritmo de ordenamiento (como burbuja o selección) para ordenar un arreglo de números.

12. **#11 - Búsqueda binaria**
    - Descripción: Crea una función que implemente la búsqueda binaria en un arreglo ordenado.

13. **#12 - Anagramas**
    - Descripción: Escribe una función que determine si dos cadenas de texto son anagramas.

14. **#13 - Combinaciones**
    - Descripción: Crea una función que genere todas las combinaciones posibles de un conjunto de elementos.

15. **#14 - Permutaciones**
    - Descripción: Escribe una función que genere todas las permutaciones posibles de un conjunto de elementos.

16. **#15 - Subconjuntos**
    - Descripción: Crea una función que genere todos los subconjuntos posibles de un conjunto de elementos.

17. **#16 - Suma de subconjuntos**
    - Descripción: Escribe una función que determine si existe un subconjunto de un arreglo cuya suma sea igual a un número dado.

18. **#17 - Producto de subconjuntos**
    - Descripción: Crea una función que determine si existe un subconjunto de un arreglo cuyo producto sea igual a un número dado.

19. **#18 - Subcadena más larga**
    - Descripción: Escribe una función que encuentre la subcadena más larga sin caracteres repetidos en una cadena de texto.

20. **#19 - Subcadena con caracteres únicos**
    - Descripción: Crea una función que determine si una cadena de texto contiene solo caracteres únicos.

### Nivel Avanzado

21. **#20 - Algoritmo de Dijkstra**
    - Descripción: Implementa el algoritmo de Dijkstra para encontrar el camino más corto en un grafo ponderado.

22. **#21 - Algoritmo de Floyd-Warshall**
    - Descripción: Crea una función que implemente el algoritmo de Floyd-Warshall para encontrar los caminos más cortos entre todos los pares de nodos en un grafo ponderado.

23. **#22 - Árboles binarios**
    - Descripción: Escribe una clase que represente un árbol binario y permita operaciones como inserción, búsqueda y recorrido en orden.

24. **#23 - Árboles balanceados**
    - Descripción: Implementa un árbol binario de búsqueda balanceado (como AVL o Red-Black Tree) y sus operaciones básicas.

25. **#24 - Grafos dirigidos**
    - Descripción: Crea una clase que represente un grafo dirigido y permita operaciones como inserción de vértices y aristas, y recorrido en profundidad.

26. **#25 - Grafos no dirigidos**
    - Descripción: Implementa una clase que represente un grafo no dirigido y permita operaciones como inserción de vértices y aristas, y recorrido en amplitud.

27. **#26 - Algoritmo de Kruskal**
    - Descripción: Escribe una función que implemente el algoritmo de Kruskal para encontrar el árbol de expansión mínima en un grafo ponderado.

28. **#27 - Algoritmo de Prim**
    - Descripción: Crea una función que implemente el algoritmo de Prim para encontrar el árbol de expansión mínima en un grafo ponderado.

29. **#28 - Backtracking**
    - Descripción: Implementa el algoritmo de backtracking para resolver problemas como el de las N reinas o el Sudoku.

30. **#29 - Programación dinámica**
    - Descripción: Escribe una función que resuelva un problema utilizando programación dinámica, como la mochila 0/1 o la secuencia de Fibonacci.